package com.tactile.tact.database.entities;

import java.util.List;


import com.tactile.tact.database.dao.DaoSession;
import de.greenrobot.dao.DaoException;

import com.tactile.tact.database.dao.ContactFeedItemDao;
import com.tactile.tact.database.dao.FrozenFeedItemDao;
import com.tactile.tact.database.dao.OpportunityFIDao;
import com.tactile.tact.database.dao.RelatedFeedItemDao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;

import com.tactile.tact.activities.TactApplication;
import com.tactile.tact.database.model.FeedItem;
import com.tactile.tact.database.model.FeedItemEmail;
import com.tactile.tact.database.model.FeedItemEvent;
import com.tactile.tact.utils.Log;
import com.tactile.tact.database.DatabaseManager;
import com.tactile.tact.database.dao.ContactFIDao;
// KEEP INCLUDES END
/**
 * Entity mapped to table FROZEN_FEED_ITEM.
 */
public class FrozenFeedItem {

    private Long id;
    private Boolean isActivity;
    private int isHidden;
    private int isDeleted;
    private int needSync;
    private String serverId;
    private Long timestamp;
    private String type;
    private String label;
    private Boolean isSeen;
    private Boolean isMaster;
    private byte[] item;
    private Integer sourceId;
    private String sourceName;
    private Long masterId;
    private long opportunityId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient FrozenFeedItemDao myDao;

    private FrozenFeedItem master;
    private Long master__resolvedKey;

    private OpportunityFI opportunity;
    private Long opportunity__resolvedKey;

    private List<FrozenFeedItem> original;
    private List<RelatedFeedItem> relatedParents;
    private List<RelatedFeedItem> relatedChilds;
    private List<ContactFeedItem> contactFeedItems;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public FrozenFeedItem() {
    }

    public FrozenFeedItem(Long id) {
        this.id = id;
    }

    public FrozenFeedItem(Long id, Boolean isActivity, int isHidden, int isDeleted, int needSync, String serverId, Long timestamp, String type, String label, Boolean isSeen, Boolean isMaster, byte[] item, Integer sourceId, String sourceName, Long masterId, long opportunityId) {
        this.id = id;
        this.isActivity = isActivity;
        this.isHidden = isHidden;
        this.isDeleted = isDeleted;
        this.needSync = needSync;
        this.serverId = serverId;
        this.timestamp = timestamp;
        this.type = type;
        this.label = label;
        this.isSeen = isSeen;
        this.isMaster = isMaster;
        this.item = item;
        this.sourceId = sourceId;
        this.sourceName = sourceName;
        this.masterId = masterId;
        this.opportunityId = opportunityId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getFrozenFeedItemDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Boolean getIsActivity() {
        return isActivity;
    }

    public void setIsActivity(Boolean isActivity) {
        this.isActivity = isActivity;
    }

    public int getIsHidden() {
        return isHidden;
    }

    public void setIsHidden(int isHidden) {
        this.isHidden = isHidden;
    }

    public int getIsDeleted() {
        return isDeleted;
    }

    public void setIsDeleted(int isDeleted) {
        this.isDeleted = isDeleted;
    }

    public int getNeedSync() {
        return needSync;
    }

    public void setNeedSync(int needSync) {
        this.needSync = needSync;
    }

    public String getServerId() {
        return serverId;
    }

    public void setServerId(String serverId) {
        this.serverId = serverId;
    }

    public Long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(Long timestamp) {
        this.timestamp = timestamp;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getLabel() {
        return label;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public Boolean getIsSeen() {
        return isSeen;
    }

    public void setIsSeen(Boolean isSeen) {
        this.isSeen = isSeen;
    }

    public Boolean getIsMaster() {
        return isMaster;
    }

    public void setIsMaster(Boolean isMaster) {
        this.isMaster = isMaster;
    }

    public byte[] getItem() {
        return item;
    }

    public void setItem(byte[] item) {
        this.item = item;
    }

    public Integer getSourceId() {
        return sourceId;
    }

    public void setSourceId(Integer sourceId) {
        this.sourceId = sourceId;
    }

    public String getSourceName() {
        return sourceName;
    }

    public void setSourceName(String sourceName) {
        this.sourceName = sourceName;
    }

    public Long getMasterId() {
        return masterId;
    }

    public void setMasterId(Long masterId) {
        this.masterId = masterId;
    }

    public long getOpportunityId() {
        return opportunityId;
    }

    public void setOpportunityId(long opportunityId) {
        this.opportunityId = opportunityId;
    }

    /** To-one relationship, resolved on first access. */
    public FrozenFeedItem getMaster() {
        Long __key = this.masterId;
        if (master__resolvedKey == null || !master__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            FrozenFeedItemDao targetDao = daoSession.getFrozenFeedItemDao();
            FrozenFeedItem masterNew = targetDao.load(__key);
            synchronized (this) {
                master = masterNew;
            	master__resolvedKey = __key;
            }
        }
        return master;
    }

    public void setMaster(FrozenFeedItem master) {
        synchronized (this) {
            this.master = master;
            masterId = master == null ? null : master.getId();
            master__resolvedKey = masterId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public OpportunityFI getOpportunity() {
        long __key = this.opportunityId;
        if (opportunity__resolvedKey == null || !opportunity__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            OpportunityFIDao targetDao = daoSession.getOpportunityFIDao();
            OpportunityFI opportunityNew = targetDao.load(__key);
            synchronized (this) {
                opportunity = opportunityNew;
            	opportunity__resolvedKey = __key;
            }
        }
        return opportunity;
    }

    public void setOpportunity(OpportunityFI opportunity) {
        if (opportunity == null) {
            throw new DaoException("To-one property 'opportunityId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.opportunity = opportunity;
            opportunityId = opportunity.getId();
            opportunity__resolvedKey = opportunityId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<FrozenFeedItem> getOriginal() {
        if (original == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            FrozenFeedItemDao targetDao = daoSession.getFrozenFeedItemDao();
            List<FrozenFeedItem> originalNew = targetDao._queryFrozenFeedItem_Original(id);
            synchronized (this) {
                if(original == null) {
                    original = originalNew;
                }
            }
        }
        return original;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetOriginal() {
        original = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<RelatedFeedItem> getRelatedParents() {
        if (relatedParents == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RelatedFeedItemDao targetDao = daoSession.getRelatedFeedItemDao();
            List<RelatedFeedItem> relatedParentsNew = targetDao._queryFrozenFeedItem_RelatedParents(id);
            synchronized (this) {
                if(relatedParents == null) {
                    relatedParents = relatedParentsNew;
                }
            }
        }
        return relatedParents;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetRelatedParents() {
        relatedParents = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<RelatedFeedItem> getRelatedChilds() {
        if (relatedChilds == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RelatedFeedItemDao targetDao = daoSession.getRelatedFeedItemDao();
            List<RelatedFeedItem> relatedChildsNew = targetDao._queryFrozenFeedItem_RelatedChilds(id);
            synchronized (this) {
                if(relatedChilds == null) {
                    relatedChilds = relatedChildsNew;
                }
            }
        }
        return relatedChilds;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetRelatedChilds() {
        relatedChilds = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<ContactFeedItem> getContactFeedItems() {
        if (contactFeedItems == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ContactFeedItemDao targetDao = daoSession.getContactFeedItemDao();
            List<ContactFeedItem> contactFeedItemsNew = targetDao._queryFrozenFeedItem_ContactFeedItems(id);
            synchronized (this) {
                if(contactFeedItems == null) {
                    contactFeedItems = contactFeedItemsNew;
                }
            }
        }
        return contactFeedItems;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetContactFeedItems() {
        contactFeedItems = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here

    /**
     * Set a FeedItem as edited
     */
    public void setItemEdited() {
        this.setNeedSync(1);
    }

    /**
     * Get if the FeedItem need to be synced
     * @return True if the Feedtem need synchronization, False otherwise
     */
    public boolean isSyncNeeded() {
        if (this.getNeedSync() == 1) {
            return true;
        }
        return false;
    }

    public boolean isEditing() {
        return this.getId() != null && this.getId() > 0;
    }

    /**
     * Get if the item already in the database
     * @return True if there is an Item with same ServerId in the database
     */
    public boolean itemExist() {
        if (TactApplication.getInstance().daoSession.getFrozenFeedItemDao().queryBuilder().where(FrozenFeedItemDao.Properties.ServerId.eq(this.serverId)).list() != null && TactApplication.getInstance().daoSession.getFrozenFeedItemDao().queryBuilder().where(FrozenFeedItemDao.Properties.ServerId.eq(this.serverId)).list().size() > 0)
            return true;
        return false;
    }

    /**
     * Get the de-serialized FeedItem from the current FrozenFeedItem
     * @return De-serialized FeedItem object
     */
    public Object getFeedItem() {
        try {
            if (this.getItem() != null) {
                FeedItem feedItem = (FeedItem)deserialize(this.getItem());
                feedItem.setParentId(this.getId());
                return feedItem;
            } else return null;
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Set a FeedItem and serialize it inside the FrozenFeedItem
     * @param object - FeddItem object
     * @throws Exception
     */
    public void setFeedItem(Object object, int needSync) throws Exception {
        try {
            if (object != null) {
                this.setItem(serialize(object));

                this.setNeedSync(needSync);
                this.setIsActivity(((FeedItem)object).getMetadata().getIsActivity());
                this.setServerId(((FeedItem)object).getServerId());
                this.setTimestamp(((FeedItem)object).getTimestamp());
                this.setType(((FeedItem)object).getMetadata().getType());
                this.setIsMaster(((FeedItem)object).getMetadata().getType().contains("Master"));
                this.setSourceId(((FeedItem)object).getSourceId());
                this.setSourceName(((FeedItem)object).getSourceType());

                //Set the objects labels
                if (object instanceof FeedItemEmail) {
                    //This grant that emails that are sended and also in inbox will show in both screens
                    if (((FeedItemEmail)object).getEmailLabels() != null && ((FeedItemEmail)object).getEmailLabels().size() > 0) {
                        this.setLabel(((FeedItemEmail)object).getEmailLabels().toString());
                    } else {
                        this.setLabel("Inbox");
                    }
                }
            } else throw new Exception("Object can't be null");
        } catch (Exception e) {
            throw e;
        }
    }

    public void setFeedItem(Object object) throws Exception {
        try {
            if (object != null) {
                this.setItem(serialize(object));
                this.setIsActivity(((FeedItem)object).getMetadata().getIsActivity());
                this.setServerId(((FeedItem)object).getServerId());
                this.setTimestamp(((FeedItem)object).getTimestamp());
                this.setType(((FeedItem)object).getMetadata().getType());
                this.setIsMaster(((FeedItem)object).getMetadata().getType().contains("Master"));
                this.setSourceId(((FeedItem)object).getSourceId());
                this.setSourceName(((FeedItem)object).getSourceType());

                //Set the objects labels
                if (object instanceof FeedItemEmail) {
                    //This grant that emails that are sended and also in inbox will show in both screens
                    if (((FeedItemEmail)object).getEmailLabels() != null && ((FeedItemEmail)object).getEmailLabels().size() > 0) {
                        this.setLabel(((FeedItemEmail)object).getEmailLabels().toString());
                    } else {
                        this.setLabel("Inbox");
                    }
                }
            } else throw new Exception("Object can't be null");
        } catch (Exception e) {
            throw e;
        }
    }

    public void updateRelations() {
        this.opportunityRelated();
        this.contactsRelated();
        this.itemsRelated();
    }

    private void opportunityRelated() {
        try {
            FeedItem feedItem = (FeedItem)this.getFeedItem();
            OpportunityFI opp = this.getOpportunity();
            if (feedItem.getMetadata().getOpportunityId() != null && feedItem.getMetadata().getOpportunityId().isEmpty()) {
                if (opp == null) {
                    opp = new OpportunityFI();
                    opp.setOpportunityId(feedItem.getMetadata().getOpportunityId());
                    TactApplication.daoSession.insert(opp);
                    this.setOpportunityId(opp.getId());
                } else if (!opp.getOpportunityId().equals(feedItem.getMetadata().getOpportunityId())) {
                    opp.setOpportunityId(feedItem.getMetadata().getOpportunityId());
                    TactApplication.daoSession.update(opp);
                }
            } else {
                if (opp != null) {
                    TactApplication.daoSession.delete(opp);
                }
            }
        } catch (Exception e) {
            Log.w("FEEDITEMSRELATED", "There was an error tryin to build opportinities relations");
        }
    }

    private void contactsRelated() {
        try {
            FeedItem feedItem = (FeedItem) this.getFeedItem();
            ArrayList<ContactFeedItem> contactFeedItemArrayList = (ArrayList<ContactFeedItem>) this.getContactFeedItems();
            if (contactFeedItemArrayList != null && contactFeedItemArrayList.size() > 0) {
                for (ContactFeedItem contactFeedItem : contactFeedItemArrayList) {
                    TactApplication.daoSession.delete(contactFeedItem);
                }
            }
            ArrayList<String> relatedContactIds = feedItem.getMetadata().getRelatedContacts();
            if (relatedContactIds == null) {
                relatedContactIds = new ArrayList<String>();
            }
            if (feedItem instanceof FeedItemEvent) {
                Contact contact = null;
                if (((FeedItemEvent) feedItem).getOrganizerEmail() != null && !((FeedItemEvent) feedItem).getOrganizerEmail().isEmpty()) {
                    contact = DatabaseManager.getContactMatchingEmail(((FeedItemEvent) feedItem).getOrganizerEmail());
                    if (contact != null && !relatedContactIds.contains(contact.getRecordID())) {
                        relatedContactIds.add(contact.getRecordID());
                    }
                }
                if (((FeedItemEvent) feedItem).getInvitedEmails() != null && ((FeedItemEvent) feedItem).getInvitedEmails().size() > 0) {
                    for (String email : ((FeedItemEvent) feedItem).getInvitedEmails()) {
                        contact = DatabaseManager.getContactMatchingEmail(email);
                        if (contact != null && !relatedContactIds.contains(contact.getRecordID())) {
                            relatedContactIds.add(contact.getRecordID());
                        }
                    }
                }
            }
            if (relatedContactIds != null && relatedContactIds.size() > 0) {
                for (String id : relatedContactIds) {
                    ContactFI contactFI = TactApplication.daoSession.getContactFIDao().queryBuilder().where(ContactFIDao.Properties.ContactId.eq(id)).unique();
                    ContactFeedItem contactFeedItem = new ContactFeedItem();
                    contactFeedItem.setFeedItemId(this.getId());
                    if (contactFI == null) {
                        contactFI = new ContactFI();
                        contactFI.setContactId(id);
                        contactFeedItem.setContactId(TactApplication.daoSession.insert(contactFI));

                    } else {
                        contactFeedItem.setContactId(contactFI.getId());
                    }
                    TactApplication.daoSession.insert(contactFeedItem);
                }
            }
        } catch (Exception e) {
            Log.w("FEEDITEMSRELATED", "There was an error tryin to build contacts relations");
        }
    }

    private void itemsRelated() {
        try {
            FeedItem feedItem = (FeedItem) this.getFeedItem();
            String masterId = feedItem.getMetadata().getMasterId();
            String originalId = feedItem.getMetadata().getOriginalId();
            for (RelatedFeedItem relatedFeedItem : this.getRelatedChilds()) {
                TactApplication.daoSession.delete(relatedFeedItem);
            }
            for (RelatedFeedItem relatedFeedItem : this.getRelatedParents()) {
                TactApplication.daoSession.delete(relatedFeedItem);
            }
            ArrayList<String> relatedIds = feedItem.getMetadata().getRelatedItems();
            if (relatedIds != null && relatedIds.size() > 0) {
                if (relatedIds.contains(masterId)) {
                    relatedIds.remove(masterId);
                }
                if (relatedIds.contains(originalId)) {
                    relatedIds.remove(originalId);
                }
                for (String id : relatedIds) {
                    FrozenFeedItem frozenFeedItem = TactApplication.daoSession.getFrozenFeedItemDao().queryBuilder().where(FrozenFeedItemDao.Properties.ServerId.eq(id)).unique();
                    if (frozenFeedItem != null) {
                        if (this.isMaster) {
                            ((FeedItem)frozenFeedItem.getFeedItem()).getMetadata().setMasterId(this.getServerId());
                            frozenFeedItem.setFeedItem(((FeedItem)frozenFeedItem.getFeedItem()));
                            frozenFeedItem.setMasterId(this.getId());
                            TactApplication.daoSession.update(frozenFeedItem);
                        } else {
                            RelatedFeedItem relatedFeedItem = new RelatedFeedItem();
                            relatedFeedItem.setParentId(this.getId());
                            relatedFeedItem.setChildId(frozenFeedItem.getId());
                        }
                    }
                }
                if (masterId != null && !masterId.isEmpty()) {
                    FrozenFeedItem frozenFeedItem = TactApplication.daoSession.getFrozenFeedItemDao().queryBuilder().where(FrozenFeedItemDao.Properties.ServerId.eq(masterId)).unique();
                    if (frozenFeedItem != null) {
                        this.setMasterId(frozenFeedItem.getId());
                        TactApplication.daoSession.update(this);
                    }
                }
                if (originalId != null && !originalId.isEmpty()) {
                    FrozenFeedItem frozenFeedItem = TactApplication.daoSession.getFrozenFeedItemDao().queryBuilder().where(FrozenFeedItemDao.Properties.ServerId.eq(originalId)).unique();
                    if (frozenFeedItem != null) {
                        frozenFeedItem.setMasterId(this.getId());
                        TactApplication.daoSession.update(frozenFeedItem);
                    }
                }
            }
        } catch (Exception e) {
            Log.w("FEEDITEMSRELATED", "There was an error tryin to build items relations");
        }
    }

    /**
     * Serialize a FeedItem object as a bytes array
     * @param obj - Objects to be serialized
     * @return A byte array representation of the object
     * @throws java.io.IOException
     */
    private byte[] serialize(Object obj) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ObjectOutputStream os = new ObjectOutputStream(out);
        os.writeObject(obj);
        return out.toByteArray();
    }

    /**
     * De-serialize a object from a byte array representation
     * @param data - Byte array representation of an object
     * @return - The object de-serialized
     * @throws java.io.IOException
     * @throws ClassNotFoundException
     */
    private Object deserialize(byte[] data) throws IOException, ClassNotFoundException {
        ByteArrayInputStream in = new ByteArrayInputStream(data);
        ObjectInputStream is = new ObjectInputStream(in);
        return is.readObject();
    }

    public ArrayList<FrozenFeedItem> getRelatedNeedSyncItems() {
        try {
            ArrayList<FrozenFeedItem> items = new ArrayList<FrozenFeedItem>();
            ArrayList<RelatedFeedItem> relateds = (ArrayList<RelatedFeedItem>)this.getRelatedChilds();
            if (relateds != null && relateds.size() > 0) {
                for (RelatedFeedItem related : relateds) {
                    if (related.getChild() != null && related.getChild().getNeedSync() == 1) {
                        items.add(related.getChild());
                    }
                    if (related.getParent() != null && related.getParent().getNeedSync() == 1) {
                        items.add(related.getParent());
                    }
                }
            }
            if (this.getMaster() != null && this.getMaster().getNeedSync() == 1 && !items.contains(this.getMaster())) {
                items.add(this.getMaster());
            }
            if (this.getOriginal() != null && this.getOriginal().size() > 0 && this.getOriginal().get(0).getNeedSync() == 1 && !items.contains(this.getOriginal().get(0))) {
                items.add(this.getOriginal().get(0));
            }
            items.add(this);
            return items;
        } catch (Exception e) {
            return null;
        }
    }
    // KEEP METHODS END

}
